import { existsSync } from 'fs';
import { join, relative } from 'pathe';
import { defuArrayFn } from 'defu';
import { watch } from 'chokidar';
import chalk from 'chalk';
import consola from 'consola';
import { defineNuxtModule, isNuxt2, requireModule, addTemplate, resolvePath, createResolver, getNuxtVersion, installModule, addVitePlugin, isNuxt3, addDevServerHandler, findPath } from '@nuxt/kit';
import 'ufo';
import { isAbsolute, resolve } from 'path';
import minimatch from 'minimatch';

class H3Error extends Error {
  constructor() {
    super(...arguments);
    this.statusCode = 500;
    this.fatal = false;
    this.unhandled = false;
    this.statusMessage = void 0;
  }
  toJSON() {
    const obj = {
      message: this.message,
      statusCode: this.statusCode
    };
    if (this.statusMessage) {
      obj.statusMessage = this.statusMessage;
    }
    if (this.data !== void 0) {
      obj.data = this.data;
    }
    return obj;
  }
}
H3Error.__h3_error__ = true;

const MIMES = {
  html: "text/html",
  json: "application/json"
};

const defer = typeof setImmediate !== "undefined" ? setImmediate : (fn) => fn();
function send(event, data, type) {
  if (type) {
    defaultContentType(event, type);
  }
  return new Promise((resolve) => {
    defer(() => {
      event.node.res.end(data);
      resolve();
    });
  });
}
function defaultContentType(event, type) {
  if (type && !event.node.res.getHeader("content-type")) {
    event.node.res.setHeader("content-type", type);
  }
}
function sendRedirect(event, location, code = 302) {
  event.node.res.statusCode = code;
  event.node.res.setHeader("location", location);
  const encodedLoc = location.replace(/"/g, "%22");
  const html = `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${encodedLoc}"></head></html>`;
  return send(event, html, MIMES.html);
}

function defineEventHandler(handler) {
  handler.__is_handler__ = true;
  return handler;
}
const eventHandler = defineEventHandler;

const name = "@nuxtjs/tailwindcss";
const version = "6.4.0";

function vitePlugin(tailwindConfig = {}, rootDir, cssPath) {
  const resolvedContent = (tailwindConfig.content || []).map((f) => !isAbsolute(f) ? resolve(rootDir, f) : f);
  return {
    name: "nuxt:tailwindcss",
    handleHotUpdate(ctx) {
      if (resolvedContent.findIndex((c) => minimatch(ctx.file, c)) === -1) {
        return;
      }
      const extraModules = ctx.server.moduleGraph.getModulesByFile(cssPath);
      const timestamp = +Date.now();
      for (const mod of extraModules) {
        ctx.server.moduleGraph.invalidateModule(mod, void 0, timestamp);
      }
      ctx.server.ws.send({
        type: "update",
        updates: Array.from(extraModules).map((mod) => {
          return {
            type: mod.type === "js" ? "js-update" : "css-update",
            path: mod.url,
            acceptedPath: mod.url,
            timestamp
          };
        })
      });
      if (ctx.file.includes("/content-cache/")) {
        return true;
      }
    }
  };
}

const defaultTailwindConfig = () => ({
  theme: {
    extend: {}
  },
  plugins: [],
  content: []
});

function resolveInjectPosition(css, position) {
  if (typeof position === "number") {
    return ~~Math.min(position, css.length + 1);
  }
  if (typeof position === "string") {
    switch (position) {
      case "first":
        return 0;
      case "last":
        return css.length;
      default:
        throw new Error("invalid literal: " + position);
    }
  }
  if (position.after !== void 0) {
    const index = css.indexOf(position.after);
    if (index === -1) {
      throw new Error("`after` position specifies a file which does not exists on CSS stack: " + position.after);
    }
    return index + 1;
  }
  throw new Error("invalid position: " + JSON.stringify(position));
}

const logger = consola.withScope("nuxt:tailwindcss");
const layerPaths = (srcDir) => [
  `${srcDir}/components/**/*.{vue,js,ts}`,
  `${srcDir}/layouts/**/*.vue`,
  `${srcDir}/pages/**/*.vue`,
  `${srcDir}/composables/**/*.{js,ts}`,
  `${srcDir}/plugins/**/*.{js,ts}`,
  `${srcDir}/App.{js,ts,vue}`,
  `${srcDir}/app.{js,ts,vue}`,
  `${srcDir}/Error.{js,ts,vue}`,
  `${srcDir}/error.{js,ts,vue}`
];
const module = defineNuxtModule({
  meta: {
    name,
    version,
    configKey: "tailwindcss"
  },
  defaults: (nuxt) => ({
    configPath: "tailwind.config",
    cssPath: join(nuxt.options.dir.assets, "css/tailwind.css"),
    config: defaultTailwindConfig(),
    viewer: true,
    exposeConfig: false,
    exposeLevel: 2,
    injectPosition: "first",
    disableHmrHotfix: false
  }),
  async setup(moduleOptions, nuxt) {
    const configPaths = [];
    const contentPaths = [];
    const addConfigPath = async (path) => {
      const paths = (Array.isArray(path) ? path : [path]).filter(Boolean);
      for (const path2 of paths) {
        const resolvedPath = await findPath(path2, { extensions: [".js", ".cjs", ".mjs", ".ts"] }, "file");
        if (resolvedPath) {
          configPaths.push(resolvedPath);
        }
      }
    };
    if (nuxt.options._layers && nuxt.options._layers.length > 1) {
      const layers = nuxt.options._layers.slice().reverse();
      for (const layer of layers) {
        await addConfigPath(layer?.config?.tailwindcss?.configPath || join(layer.cwd, "tailwind.config"));
        contentPaths.push(...layerPaths(layer.cwd));
      }
    } else {
      await addConfigPath(moduleOptions.configPath);
      contentPaths.push(...layerPaths(nuxt.options.srcDir));
    }
    if (nuxt.options.dev) {
      if (isNuxt2()) {
        nuxt.options.watch = nuxt.options.watch || [];
        configPaths.forEach((path) => nuxt.options.watch.push(path));
      } else {
        watch(configPaths).on("change", (path) => {
          logger.info(`Tailwind config changed: ${path}`);
          logger.warn("Please restart the Nuxt server to apply changes");
        });
      }
    }
    let tailwindConfig = defuArrayFn(moduleOptions.config, { content: contentPaths });
    for (const configPath of configPaths) {
      let _tailwindConfig;
      try {
        _tailwindConfig = requireModule(configPath, { clearCache: true });
      } catch (e) {
        logger.warn(`Failed to load Tailwind config at: \`./${relative(nuxt.options.rootDir, configPath)}\``, e);
      }
      if (_tailwindConfig && Array.isArray(_tailwindConfig.purge) && !_tailwindConfig.content) {
        _tailwindConfig.content = _tailwindConfig.purge;
      }
      if (_tailwindConfig) {
        tailwindConfig = defuArrayFn(_tailwindConfig, tailwindConfig);
      }
    }
    const resolveConfig = await import('tailwindcss/resolveConfig.js').then((r) => r.default || r);
    const resolvedConfig = resolveConfig(tailwindConfig);
    resolvedConfig.plugins = [];
    addTemplate({
      filename: "tailwind.config.cjs",
      getContents: () => `module.exports = ${JSON.stringify(resolvedConfig, null, 2)}`,
      write: true
    });
    if (moduleOptions.exposeConfig) {
      const populateMap = (obj, path = [], level = 1, maxLevel = moduleOptions.exposeLevel) => {
        Object.entries(obj).forEach(([key, value = {}]) => {
          if (level >= maxLevel || typeof value !== "object" || Array.isArray(value) || Object.keys(value).find((k) => !k.match(/^[0-9a-z]+$/i))) {
            addTemplate({
              filename: `tailwind.config/${path.concat(key).join("/")}.mjs`,
              getContents: () => `export default ${JSON.stringify(value, null, 2)}`
            });
          } else {
            populateMap(value, path.concat(key), level + 1, maxLevel);
            const values = Object.keys(value);
            addTemplate({
              filename: `tailwind.config/${path.concat(key).join("/")}.mjs`,
              getContents: () => `${Object.keys(value).map((v) => `import _${v} from "./${key}/${v}.mjs"`).join("\n")}
const config = { ${values.map((k) => `"${k}": _${k}`).join(", ")} }
export { config as default${values.length > 0 ? ", _" : ""}${values.join(", _")} }`
            });
          }
        });
      };
      populateMap(resolvedConfig);
      const configOptions = Object.keys(resolvedConfig);
      const template = addTemplate({
        filename: "tailwind.config.mjs",
        getContents: () => `${configOptions.map((v) => `import ${v} from "./tailwind.config/${v}.mjs"`).join("\n")}
const config = { ${configOptions.join(", ")} }
export { config as default, ${configOptions.join(", ")} }`
      });
      addTemplate({
        filename: "tailwind.config.d.ts",
        getContents: () => `type tailwindcssConfig = import("tailwindcss").Config
declare const config: tailwindcssConfig
${configOptions.map((o) => `declare const ${o}: tailwindcssConfig["${o}"]`).join("\n")}
export { config as default, ${configOptions.join(", ")} }`,
        write: true
      });
      nuxt.options.alias["#tailwind-config"] = template.dst;
    }
    await nuxt.callHook("tailwindcss:config", tailwindConfig);
    tailwindConfig._hash = String(Date.now());
    const cssPath = typeof moduleOptions.cssPath === "string" ? await resolvePath(moduleOptions.cssPath, { extensions: [".css", ".sass", ".scss", ".less", ".styl"] }) : false;
    let resolvedCss;
    if (typeof cssPath === "string") {
      if (existsSync(cssPath)) {
        logger.info(`Using Tailwind CSS from ~/${relative(nuxt.options.srcDir, cssPath)}`);
        resolvedCss = cssPath;
      } else {
        logger.info("Using default Tailwind CSS file from runtime/tailwind.css");
        resolvedCss = createResolver(import.meta.url).resolve("runtime/tailwind.css");
      }
    } else {
      logger.info("No Tailwind CSS file found. Skipping...");
      resolvedCss = createResolver(import.meta.url).resolve("runtime/empty.css");
    }
    nuxt.options.css = nuxt.options.css ?? [];
    const resolvedNuxtCss = await Promise.all(nuxt.options.css.map((p) => resolvePath(p.src ?? p)));
    if (!resolvedNuxtCss.includes(resolvedCss)) {
      let injectPosition;
      try {
        injectPosition = resolveInjectPosition(nuxt.options.css, moduleOptions.injectPosition);
      } catch (e) {
        throw new Error("failed to resolve Tailwind CSS injection position: " + e.message);
      }
      nuxt.options.css.splice(injectPosition, 0, resolvedCss);
    }
    const postcssOptions = nuxt.options.postcss || nuxt.options.build.postcss.postcssOptions || nuxt.options.build.postcss;
    postcssOptions.plugins = postcssOptions.plugins || {};
    postcssOptions.plugins["tailwindcss/nesting"] = postcssOptions.plugins["tailwindcss/nesting"] ?? {};
    postcssOptions.plugins["postcss-custom-properties"] = postcssOptions.plugins["postcss-custom-properties"] ?? {};
    postcssOptions.plugins.tailwindcss = tailwindConfig;
    const nuxtVersion = getNuxtVersion(nuxt).split(".");
    if (parseInt(nuxtVersion[0], 10) === 2 && parseInt(nuxtVersion[1], 10) < 16) {
      await installModule("@nuxt/postcss8");
    }
    if (nuxt.options.dev && !moduleOptions.disableHmrHotfix) {
      addVitePlugin(vitePlugin(tailwindConfig, nuxt.options.rootDir, resolvedCss));
    }
    if (nuxt.options.dev && moduleOptions.viewer) {
      const route = "/_tailwind";
      const createServer = await import('tailwind-config-viewer/server/index.js').then((r) => r.default || r);
      const { withTrailingSlash, withoutTrailingSlash } = await import('ufo');
      const routerPrefix = isNuxt3() ? route : void 0;
      const _viewerDevMiddleware = createServer({ tailwindConfigProvider: () => tailwindConfig, routerPrefix }).asMiddleware();
      const viewerDevMiddleware = eventHandler((event) => {
        if (event.req.url === withoutTrailingSlash(route)) {
          return sendRedirect(event, withTrailingSlash(event.req.url), 301);
        }
        _viewerDevMiddleware(event.req, event.res);
      });
      if (isNuxt3()) {
        addDevServerHandler({ route, handler: viewerDevMiddleware });
      }
      if (isNuxt2()) {
        nuxt.options.serverMiddleware.push({ route, handler: viewerDevMiddleware });
      }
      nuxt.hook("listen", (_, listener) => {
        const viewerUrl = `${withoutTrailingSlash(listener.url)}${route}`;
        logger.info(`Tailwind Viewer: ${chalk.underline.yellow(withTrailingSlash(viewerUrl))}`);
      });
    }
    if (nuxt.options.dev) {
      nuxt.hook("devtools:customTabs", (tabs) => {
        tabs.push({
          title: "TailwindCSS",
          name: "tailwindcss",
          icon: "logos-tailwindcss-icon",
          view: {
            type: "iframe",
            src: "/_tailwind/"
          }
        });
      });
    }
  }
});

export { module as default };
